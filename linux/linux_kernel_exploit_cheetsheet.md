[TOC]

### 驱动编程

书籍：
[linux设备驱动](https://www.kancloud.cn/kancloud/ldd3)

动态分配设备号
```c
int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name);
```

dev是传出参数，为动态获得的设备号；firstminor指定第一个minor；count和name同register_chrdev_region的参数定义。
[http://nanxiao.me/linux-kernel-note-20-device-major-minor-number/]()

静态初始化字符设备：
```c
struct cdev my_cdev;

cdev_init(&my_cdev, &fops);

my_cdev.owner = THIS_MODULE;
```
[ Linux字符设备驱动之cdev_init()系列 ](http://blog.csdn.net/tigerjibo/article/details/6412613)

class相关api
![ ](http://images.cnitblog.com/blog/497634/201305/15222645-cd23dedafac144bbbb027aa4bc5c79b8.jpg  "class相关api")

[class_create和class_register](http://www.cnblogs.com/skywang12345/archive/2013/05/15/driver_class.html)

### 解压cpio格式的rootfs

rootfs.cpio是先cpio打包再gzip压缩

解压要先把rootfs.cpio改成gz后缀再解压，否则会报错。

### exploit tech & tricks

#### tty_struct spray

`man 4 ptmx`可以了解到:
```
When a process opens /dev/ptmx, it gets a file descriptor for a pseudoterminal master (PTM), and a pseudoterminal slave (PTS) device is created in the /dev/pts directory. Each file descriptor obtained by opening /dev/ptmx is an independent PTM with its own associated PTS, whose path can be found by passing the descriptor to ptsname(3). 
```

也就是新建了一个`tty_struct`,而这个结构[tty_struct](http://elixir.free-electrons.com/linux/v4.4.72/source/include/linux/tty.h#L259)里有个字段`const struct tty_oprations* ops`我们可以将其改写成某个包含恶意函数指针的地址，比如在没有`SMAP`的时候可以直接指向用户空间，从而控制执行流。

所以在存在uaf的情况下，可以spray大量`tty_struct`从而占坑我们之前释放的chunk，然后uaf将`ops`改成自己的地址。

参考practice：[simple kernel exploit challenge](http://bobao.360.cn/learning/detail/4148.html)

#### uaf use struct cred

与`tty_struct spary`类似，也是占坑，如果`fork`一个子进程能刚好令子进程的`cred`结构进入我们想要的位置，那么就可以直接改写`cred`的内容从而提权。

参考practice：[simple kernel exploit challenge](http://bobao.360.cn/learning/detail/4148.html)

#### Mitigration

* kaslr 可通过`cat /proc/cmdline`来查看，选项若有kaslr则是开启，一般内核默认不开启。
* smep可以通过`cat /proc/cpuinfo`查看flags有没有smep


### 内核Debug

#### 启动

qemu可以直接加参数`-gdb tcp::23333`,但是要注意gdb连接server时候会出错，所以要用`set architecture i386:x86-64`指定构架然后`target remote :23333`连接。

参考：[https://stackoverflow.com/questions/8662468/remote-g-packet-reply-is-too-long]()

#### kallsyms

大部分时候我们是调试驱动，而kallsyms拥有内核中所有的符号，也包括了驱动模块的，所以可以查看kallsyms来下模块的断点。

### 制作cpio，initramfs文件系统

需要两个工具，一个是进入内核源码编译的：
`make -C /usr/src/linux/usr/ gen_init_cpio`
一个是内核源码目录script下的`chmod +x usr/gen_init_cpio scripts/gen_initramfs_list.sh `

然后通过以下命令创建initramfs文件系统：

```shell
gen_initramfs_list.sh initrd/ > filelist
gen_init_cpio filelist >initrd.img
gzip initrd.img
mv initrd.img initrd-`uname –r`.img
```

### 关于cred结构

默认编译的cred前5个字段为:
```c
struct cred {
	unsigned long usage;
	unsigned int uid;
	unsigned int gid;
	unsigned int suid;
	unsigned int sgid;
	unsigned int euid;
	...
};
```

测试要把这些字段全部清零才能获得root权限,usage字段是跟bit有关的，32位下是`unsigned int`，在64位下，默认设置的cred结构是0xa8字节大小

### 返回用户态

64位下使用的是`swapgs`和`iretq`，前者将gs和MSR的数据进行交换，后者会从栈上按以下顺序弹出数据：
```

    the next RIP
    user land CS
    user land EFLAGS
    user land RSP
    user land SS

```

### 获得内核编译选项

有时候我们希望获得内核编译时的选项，如要获得一个结构的大小(此时光有源码是不够的)，可以通过以下方式获取：

在运行时：

```shell
#Current kernel config:

cat /boot/config-`uname -r`

#Other installed kernels:

ls /boot/config-*

#以下三种都是可能的

 /proc/config.gz
 /boot/config
 /boot/config-$(uname -r)
```

拥有镜像时：
这时候需要用到内核源码下`scripts/extract-ikconfig`脚本来获取镜像中的config，但是这也需要内核在编译时启用了`CONFIG_IKCONFIG_PROC`选项。

### 从被压缩的镜像中提取vmlinux

使用内核源码里的`scripts/extract-vmlinux`就能很容易提取出来了：
`./extract-vmlinux bzImage > vmlinx`

### linux kernel

#### stack

[Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈](http://kyang.cc/2016/08/26/Linux-%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%88%EF%BC%9A%E8%BF%9B%E7%A8%8B%E6%A0%88-%E7%BA%BF%E7%A8%8B%E6%A0%88-%E5%86%85%E6%A0%B8%E6%A0%88-%E4%B8%AD%E6%96%AD%E6%A0%88/)

